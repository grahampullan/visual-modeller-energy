var visualModellerEnergy=function(t){"use strict";class e{constructor(t){this.name=t.name||"socket",this.state=t.state||{},this.position=t.position||"left"}}class s{constructor(t){this.name=t.name||"log",this.target=t.target||null,this.states=[]}writeToLog(){this.states.push({...this.target.state})}clear(){this.states=[]}}class a{constructor(t){t=t||{},this.nodes=t.nodes||[],this.links=t.links||[],this.logs=t.logs||[],this.maxNodeId=0,this.maxLinkId=0,this.maxLogId=0}getNodeId(){let t=`node-${this.maxNodeId}`;return this.maxNodeId++,t}getLinkId(){let t=`link-${this.maxLinkId}`;return this.maxLinkId++,t}getLogId(){let t=`log-${this.maxLogId}`;return this.maxLogId++,t}addNode(t){t.id=this.getNodeId(),this.nodes.push(t)}addLink(t){t.id=this.getLinkId();const e=t.socket1;e.link=t,e.otherSocket=t.socket2;const s=t.socket2;s.link=t,s.otherSocket=t.socket1,this.links.push(t)}addLog(t){t.id=this.getLogId(),this.logs.push(t)}removeNode(t){this.nodes=this.nodes.filter((e=>e!==t))}removeLink(t){this.links=this.links.filter((e=>e!==t))}removeLog(t){this.logs=this.logs.filter((e=>e!==t))}removeNodeById(t){this.nodes=this.nodes.filter((e=>e.id!==t))}removeLinkById(t){this.links=this.links.filter((e=>e.id!==t))}removeLogById(t){this.logs=this.logs.filter((e=>e.id!==t))}clearLogs(){this.logs.forEach((t=>t.clear()))}getLinkBySocket(t){return this.links.find((e=>e.socket1===t||e.socket2===t))}getNodeBySocket(t){return this.nodes.find((e=>e.sockets.includes(t)))}getNodeByName(t){return this.nodes.find((e=>e.name===t))}getLinkByName(t){return this.links.find((e=>e.name===t))}getNodeClassByClassName(t){if(!this.availableNodeClasses)return null;const e=this.availableNodeClasses.map((t=>(new t).className)).indexOf(t);return-1===e?null:this.availableNodeClasses[e]}getLinkClassByClassName(t){if(!this.availableLinkClasses)return null;if(1===this.availableLinkClasses.length)return this.availableLinkClasses[0];const e=this.availableLinkClasses.map((t=>(new t).className)).indexOf(t);return-1===e?null:this.availableLinkClasses[e]}get allSockets(){return this.nodes.map((t=>t.sockets)).flat()}getSocketByName(t){return console.log(this.allSockets.map((t=>t.name))),console.log(t),this.allSockets.find((e=>e.name==t))}toJson(){const t={};return t.config=this.config,t.nodes=this.nodes.map((t=>{const e={};return e.name=t.name,e.className=t.className,e.state=t.state,e.sockets=t.sockets.map((t=>{const e={};return e.name=t.name,e.position=t.position,e.state=t.state,e})),e})),t.links=this.links.map((t=>{const e={};return e.name=t.name,e.socket1Name=t.socket1.name,e.socket2Name=t.socket2.name,e})),t.logs=this.logs.map((t=>{const e={};return e.name=t.name,e.targetName=t.target.name,e})),JSON.stringify(t)}saveToFile(){const t=this.toJson(),e=new Blob([t],{type:"application/json"}),s=URL.createObjectURL(e),a=document.createElement("a");a.href=s,a.download="model.json",a.click()}fromJsonObject(t){console.log(t),this.config=t.config,t.nodes.forEach((t=>{const s=new(this.getNodeClassByClassName(t.className))(t);s.sockets=t.sockets.map((t=>new e(t))),console.log(s),this.addNode(s)})),console.log("nodes added"),t.links.forEach((t=>{console.log(t);const e=this.getSocketByName(t.socket1Name),s=this.getSocketByName(t.socket2Name);let a;console.log(e,s),a=t.className?this.getLinkClassByClassName(t.className):this.getLinkClassByClassName(),console.log(a),console.log(this.availableLinkClasses),this.addLink(new a({name:t.name,socket1:e,socket2:s})),console.log("link added")})),console.log("links added"),t.logs.forEach((t=>{console.log(t);const e=this.getNodeByName(t.targetName),a=this.getLinkByName(t.targetName);console.log(e,a);const o=e||a;console.log(o),this.addLog(new s({name:t.name,target:o}))})),console.log("logs added")}async loadFromUrl(t){const e=await fetch(t),s=await e.json();this.fromJsonObject(s)}}class o{constructor(t){this.name=t.name||"node",this.sockets=[],this.state=t.state||{},this.maxSocketId=0,t.sockets&&t.sockets.forEach((t=>{this.addSocket(t)}))}getSocketId(){let t=`socket-${this.maxSocketId}`;return this.maxSocketId++,t}get leftSockets(){return this.sockets.filter((t=>"left"===t.position))}get rightSockets(){return this.sockets.filter((t=>"right"===t.position))}get topSockets(){return this.sockets.filter((t=>"top"===t.position))}get bottomSockets(){return this.sockets.filter((t=>"bottom"===t.position))}addSocket(t){t.id=this.getSocketId(),this.sockets.push(t)}setSocketByIndex(t,e){e.id=this.getSocketId(),this.sockets[t]=e}getSocketByIndex(t){return this.sockets[t]}getSocketByName(t){return this.sockets.find((e=>e.name===t))}removeSocket(t){this.sockets=this.sockets.filter((e=>e!==t))}removeSocketById(t){this.sockets=this.sockets.filter((e=>e.id!==t))}removeSocketByIndex(t){this.sockets=this.sockets.filter(((e,s)=>s!==t))}}class i{constructor(t){t=t||{},this.name=t.name||"link",this.socket1=t.socket1||null,this.socket2=t.socket2||null,this.state=t.state||{}}getOtherSocket(t){return t===this.socket1?this.socket2:t===this.socket2?this.socket1:null}}class n extends o{constructor(t){super(t=t||{})}setConstraints(){}updateState(){}}class l extends n{constructor(t){super(t=t||{}),this.className="gridExportNode",this.type="endNode";const s={};s.name=t.socketName||"Grid Export",s.position=t.position||"left",s.state=t.socketState||{max:1/0,value:null,valueType:"variable"},this.setSocketByIndex(0,new e(s))}}class c extends n{constructor(t){super(t=t||{}),this.className="gridSupplyNode",this.type="endNode";const s={};s.name=t.socketName||"Grid Supply",s.position=t.position||"right",s.state=t.socketState||{max:1/0,value:null,valueType:"variable"},this.setSocketByIndex(0,new e(s))}}class r extends n{constructor(t){super(t=t||{}),this.className="loadNode",this.type="endNode";const s={};s.name=t.socketName||"Load",s.position=t.position||"left",s.state=t.socketState||{max:null,value:null,valueType:"constraint",timeVarying:!1,timeSeries:null},this.setSocketByIndex(0,new e(s))}setConstraints(){const t=this.getSocketByIndex(0).state;"constraint"===t.valueType&&t.timeVarying&&(t.value=t.timeSeries[this.timeStep])}}class h extends n{constructor(t){super(t=t||{}),this.className="solarPVNode",this.type="endNode";const s={};s.name=t.socketName||"Solar PV",s.position=t.position||"right",s.state=t.socketState||{max:null,value:null,valueType:"constraint",timeVarying:!1,timeSeries:null},this.setSocketByIndex(0,new e(s))}setConstraints(){const t=this.getSocketByIndex(0).state;"constraint"!==!t.valueType&&t.timeVarying&&(t.value=t.timeSeries[this.timeStep])}}class m extends n{constructor(t){super(t=t||{}),this.class="controllerNode",this.type="controllerNode"}setFluxTargets(){const t=this.state.inputSocketOrder,e=this.state.outputSocketOrder,s=t.map((t=>this.getSocketByName(t))),a=e.map((t=>this.getSocketByName(t))),o=s.map((t=>t.otherSocket)),i=a.map((t=>t.otherSocket));let n=o.filter((t=>"constraint"==t.state.valueType)).reduce(((t,e)=>t+e.state.value),0),l=i.filter((t=>"constraint"==t.state.valueType)).reduce(((t,e)=>t+e.state.value),0);n>=l?(i.forEach((t=>{if("constraint"==t.state.valueType){const e=t.otherSocket;e.state.value=null,e.state.valueType="variable",e.state.max=1/0,n-=t.state.value}})),i.forEach((t=>{if("variable"==t.state.valueType){const e=t.otherSocket,s=Math.min(n,t.state.max);e.state.value=s,e.state.valueType="target",n-=s}})),o.forEach((t=>{if("constraint"==t.state.valueType){const e=t.otherSocket;e.state.value=null,e.state.valueType="variable",e.state.max=1/0}if("variable"==t.state.valueType){const e=t.otherSocket;e.state.value=0,e.state.valueType="target"}}))):(o.forEach((t=>{if("constraint"==t.state.valueType){const e=t.otherSocket;e.state.value=null,e.state.valueType="variable",e.state.max=1/0,l-=t.state.value}})),o.forEach((t=>{if("variable"==t.state.valueType){const e=t.otherSocket,s=Math.min(l,t.state.max);e.state.value=s,e.state.valueType="target",l-=s}})),i.forEach((t=>{if("constraint"==t.state.valueType){const e=t.otherSocket;e.state.value=null,e.state.valueType="variable",e.state.max=1/0}if("variable"==t.state.valueType){const e=t.otherSocket;e.state.value=0,e.state.valueType="target"}})))}}class d extends n{constructor(t){(t=t||{}).state=t.state||{},t.state.maxCharge=t.state.maxCharge||3e3,t.state.maxDischarge=t.state.maxDischarge||3e3;const s=[new e({name:"Input",position:"left",state:{max:t.state.maxCharge,value:null,valueType:"variable"}}),new e({name:"Output",position:"right",state:{max:t.state.maxDischarge,value:null,valueType:"variable"}})];t.sockets=t.sockets||s,t.state.capacity=t.state.capacity||5,super(t),this.state.charge=0,this.className="batteryStorageNode",this.type="storageNode"}updateState(){const t=36e5,e=this.leftSockets,s=this.rightSockets,a=e.map((t=>t.link)),o=s.map((t=>t.link)),i=a.map((t=>t.state.value)),n=o.map((t=>t.state.value)),l=i.reduce(((t,e)=>t+e),0)-n.reduce(((t,e)=>t+e),0),c=this.state.capacity-this.state.charge,r=Math.min(l*this.timeStepSize/t,c);this.state.charge+=r;let h=Math.min(this.state.maxDischarge,this.state.charge*t);h=Math.max(h,0);const m=Math.min(this.state.maxCharge,(this.state.capacity-this.state.charge)*t);this.getSocketByIndex(0).state.max=m,this.getSocketByIndex(1).state.max=h}}class u extends i{constructor(t){super(t)}setFlux(){const t=this.socket1.state,e=this.socket2.state;t.valueType==e.valueType&&console.log("warning - both sockets for this link have the same valueType",this),"variable"!=e.valueType||"constraint"!=t.valueType&&"target"!=t.valueType||(t.value<=e.max?this.state.value=t.value:console.log("problem - variable value exceeds constraint max",this)),"variable"!=t.valueType||"constraint"!=e.valueType&&"target"!=e.valueType||(e.value<=t.max?this.state.value=e.value:console.log("problem - variable value exceeds constraint max",this))}}return t.BatteryStorageNode=d,t.ControllerNode=m,t.GridExportNode=l,t.GridSupplyNode=c,t.Link=u,t.LoadNode=r,t.Log=s,t.Model=class extends a{constructor(t){super(t=t||{});const e=t.config||{},s={};s.timeVarying=e.timeVarying||!1,s.timeSteps=e.timeSteps||1,s.timeStepSize=e.timeStepSize||1,this.config=s,this.timeStep=0}get availableNodeClasses(){return[d,m,l,c,r,h]}get availableLinkClasses(){return[u]}setTimeStep(t){this.timeStep=t,this.nodes.forEach((e=>e.timeStep=t))}setTimeStepSize(t){this.config.timeStepSize=t,this.nodes.forEach((e=>e.timeStepSize=t))}run(){const t=this.nodes,e=this.links,s=this.logs,a=this.config.timeVarying,o=this.config.timeSteps,i=this.config.timeStepSize;this.setTimeStepSize(i),a||(this.timeSteps=1);for(let a=0;a<o;a++)this.setTimeStep(a),t.forEach((t=>t.setConstraints())),t.filter((t=>"controllerNode"===t.type)).forEach((t=>t.setFluxTargets())),e.forEach((t=>t.setFlux())),t.forEach((t=>t.updateState())),s.forEach((t=>t.writeToLog()))}},t.Socket=e,t.SolarPVNode=h,t}({});
//# sourceMappingURL=visual-modeller-energy.min.js.map
