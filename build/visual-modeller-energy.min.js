var visualModellerEnergy=function(t){"use strict";class s{constructor(t){this.nodes=t.nodes||[],this.links=t.links||[],this.logs=t.logs||[],this.maxNodeId=0,this.maxLinkId=0,this.maxLogId=0}getNodeId(){let t=`node-${this.maxNodeId}`;return this.maxNodeId++,t}getLinkId(){let t=`link-${this.maxLinkId}`;return this.maxLinkId++,t}addNode(t){t.id=this.getNodeId(),this.nodes.push(t)}addLink(t){t.id=this.getLinkId(),this.links.push(t)}addLog(t){t.id=this.getLogId(),this.logs.push(t)}removeNode(t){this.nodes=this.nodes.filter((s=>s!==t))}removeLink(t){this.links=this.links.filter((s=>s!==t))}removeLog(t){this.logs=this.logs.filter((s=>s!==t))}removeNodeById(t){this.nodes=this.nodes.filter((s=>s.id!==t))}removeLinkById(t){this.links=this.links.filter((s=>s.id!==t))}removeLogById(t){this.logs=this.logs.filter((s=>s.id!==t))}}class e{constructor(t){this.name=t.name||"node",this.sockets=[],this.state=t.state||{},this.maxSocketId=0,t.sockets&&t.sockets.forEach((t=>{this.addSocket(t)}))}getSocketId(){let t=this.maxSocketId;return this.maxSocketId++,t}get leftSockets(){return this.sockets.filter((t=>"left"===t.position))}get rightSockets(){return this.sockets.filter((t=>"right"===t.position))}get topSockets(){return this.sockets.filter((t=>"top"===t.position))}get bottomSockets(){return this.sockets.filter((t=>"bottom"===t.position))}addSocket(t){t.id=this.getSocketId(),this.sockets.push(t)}setSocketByIndex(t,s){s.id=this.getSocketId(),this.sockets[t]=s}getSocketByIndex(t){return this.sockets[t]}removeSocket(t){this.sockets=this.sockets.filter((s=>s!==t))}removeSocketById(t){this.sockets=this.sockets.filter((s=>s.id!==t))}removeSocketByIndex(t){this.sockets=this.sockets.filter(((s,e)=>e!==t))}}class i{constructor(t){this.name=t.name||"socket",this.state=t.state||{},this.linkId=t.linkId||"",this.position=t.position||"left"}}class o{constructor(t){this.socket1=t.socket1||null,this.socket2=t.socket2||null,this.state=t.state||{}}}class n extends e{constructor(t){super(t)}setConstraints(){}updateState(){}}return t.ControllerNode=class extends n{constructor(t){super(t),this.class="controlNode",this.type="controller",this.inputSocketOrder=t.inputSocketOrder||[],this.outputSocketOrder=t.outputSocketOrder||[]}},t.GridExportNode=class extends n{constructor(t){super(t),this.class="endNode",this.type="gridExport";const s={};s.name=t.name||"Grid Export",s.linkId=t.linkId||"",s.position=t.position||"left",s.state=t.state||{max:1/0,value:null,constraint:!1},this.setSocketByIndex(0,new i(s))}},t.GridSupplyNode=class extends n{constructor(t){super(t),this.class="endNode",this.type="gridSupply";const s={};s.name=t.name||"Grid Supply",s.linkId=t.linkId||"",s.position=t.position||"right",s.state=t.state||{max:1/0,value:null,constraint:!1},console.log(this),this.setSocketByIndex(0,new i(s))}},t.Link=class extends o{constructor(t){super(t)}setFlux(){const t=this.socket1.state,s=this.socket2.state;t.constraint&&(s.constraint?console.log("problem - both sockets have constraints",this):t.value<=s.max&&(this.state.value=t.value)),s.constraint&&(t.constraint?console.log("problem - both sockets have constraints",this):s.value<=t.max&&(this.state.value=s.value))}},t.LoadNode=class extends n{constructor(t){super(t),this.class="endNode",this.type="loadNode";const s={};s.name=t.name||"Load",s.linkId=t.linkId||"",s.position=t.position||"left",s.state=t.state||{max:null,value:null,constraint:!0,timeVarying:!1,timeSeries:null},this.setSocketByIndex(0,new i(s))}setConstraints(t){const s=t.timeStep,e=this.getSocketByIndex(0).state;e.constraint&&e.timeVarying&&(e.value=e.timeSeries[s])}},t.Log=class{constructor(t){this.name=t.name||"log",this.target=t.target||null,this.values=[]}addToLog(){this.values.push(this.target)}},t.Model=class extends s{constructor(t){super(t),this.timeVarying=t.timeVarying||!1,this.timeSteps=t.timeSteps||1,this.timeStep=0}run(){const t=this.nodes,s=this.links,e=this.logs,i=this.timeVarying,o=this.timeSteps;i||(this.timeSteps=1);for(let i=0;i<o;i++)this.timeStep=i,t.forEach((t=>t.setConstraints({timeStep:i}))),t.filter((t=>"controller"===t.type)).forEach((t=>t.setFluxTargets())),s.forEach((t=>t.setFlux())),t.forEach((t=>t.updateState())),e.forEach((t=>t.writeToLog()))}},t.SolarPVNode=class extends n{constructor(t){super(t),this.class="endNode",this.type="solarPVNode";const s={};s.name=t.name||"Solar PV",s.linkId=t.linkId||"",s.position=t.position||"right",s.state=t.state||{max:null,value:null,constraint:!0,timeVarying:!1,timeSeries:null},this.setSocketByIndex(0,new i(s))}setConstraints(t){const s=t.timeStep,e=this.getSocketByIndex(0).state;e.constraint&&e.timeVarying&&(e.value=e.timeSeries[s])}},t}({});
//# sourceMappingURL=visual-modeller-energy.min.js.map
